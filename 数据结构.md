# 数据结构知识点
* [红黑树](#红黑树)
* [B树与B+详解 ](#B树与B+详解 )

<span id="红黑树"></span>
## 红黑树
* 节点是黑色或者红色
* 根节点是黑色
* 每个叶节点（NIL节点，空节点）是黑色的
* 每个红节点的两个子节点都是黑色的
* 从任一节点到其每个叶子节点的所有路径都包含相同数目的黑色节点

<span id="B树与B+详解"></span>
## B树与B+详解 
目的：降低树的深度，提高查找效率  
[参考链接：B树与B+详解](https://www.cnblogs.com/guohai-stronger/p/9225057.html)
### B树
m阶的B树：
1. 树中的每个结点**最多含有m个孩子**；
2. 除了根结点和叶子结点，其他结点**至少有[ceil(m / 2)（代表是取上限的函数）]个孩子**；
3. 若根结点不是叶子结点时，则**至少有两个孩子**（除了没有孩子的根结点）
4. 所有的**叶子结点都出现在同一层中**，**叶子结点不包含任何关键字信息**；  

* B树的插入：
  1. 如果B树已存在需要插入的键值时，用新的值替换旧的值
  2. 若B树不存在这个值时，则是在叶子结点进行插入操作。
  
* 一棵含有N个总关键字数的m阶的B树的最大高度是多少?  
  1. log_ceil(m/2)((N+1)/2)+1=**log┌m/2┐((N+1)/2)+1**
  2. 树中每个结点含有最多含有m个孩子，即m满足：ceil(m/2)<=m<=m
### B+树
![B+树](https://i.ibb.co/MZ9Pb4X/B.jpg)  
1. 有n棵子树的结点含有n个关键字，每个**关键字都不会保存数据，只会用来索引**，并且**所有数据都会保存在叶子结点**；
2. 所有的叶子结点包含所有关键字信息以及指向关键字记录的指针，关键字自小到大顺序连接；
* B+树插入：
  1. 若为空树，直接插入，此时也就是根结点
  2. 对于叶子结点：根据key找叶子结点，对叶子结点进行插入操作。插入后，如果当前结点key的个数不大于m-1，则插入就结束。
    >> 反之将这个叶子结点分成左右两个叶子结点进行操作，左叶子结点包含了前m/2个记录，右结点包含剩下的记录key，将第m/2+1个记录的key进位到父结点中（父结点必须是索引类型结点），进位到父结点中的key左孩子指针向左结点,右孩子指针向右结点。
  3. 针对索引结点：如果当前结点key的个数小于等于m-1，插入结束。
    >> 反之将这个索引类型结点分成两个索引结点，左索引结点包含前(m-1)/2个数据，右结点包含m-(m-1)/2个数据，然后将第m/2个key父结点中，进位到父结点的key左孩子指向左结点, 父结点的key右孩子指向右结点。

* B+树适合做操作系统的数据库索引和文件索引的原因：
  * B+树的磁盘读写的代价更低
    * **内部结点没有指向关键字具体信息的指针**
  * B+树的查询更加的稳定
    * 非终端结点仅仅作为叶子结点的关键字索引，因此所有的关键字查询都会走一条从根节点到叶子结点的路径。**即s所有关键字查询的长度是一样的，查询效率稳定**
