# 操作系统
[进程与线程](#进程与线程)  
[互斥锁与读写锁](#互斥锁与读写锁)

## 进程与线程
* **进程**
  * 对运行时程序的封装
  * **系统进行资源调度和分配的的基本单位**
  * 实现了操作系统的并发
* **线程**
  * 进程的子任务
  * **CPU调度和分派的基本单位**
  * 用于保证程序的实时性，实现进程内部的并发
### 区别
* 线程依赖于进程而存在
  * 一个线程只能属于一个进程，一个进程至少有一个线程，可以有多线程
* 进程是资源分配的最小单位，线程是CPU调度的最小单位
* 一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。
* 系统开销  进程大
  * 创建或撤消进程时，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销
* 通信
  * 同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易
  * 进程间通信，需要进程同步和互斥手段的辅助
* 调试
  * 进程简单可靠性高，线程编程调试相对复杂
### 进程间的通信方式
**管道**、系统IPC（包括**消息队列、信号量、信号、共享内存**等）、以及套接字socket
* 管道
  * 无名管道：可用于具有亲缘关系的父子进程间的通信
  * 有名管道：允许无亲缘关系进程间的通信
* 系统IPC
  * 消息队列
    * 消息不一定要以先进先出的次序读取,也可以按消息的类型读取
  * 信号量
    * 是一个计数器，可以用来控制多个进程对共享资源的访问
    * 用于实现进程间的互斥与同步，而不是用于存储进程间通信数据
  * 信号
    * 用于通知接收进程某个事件已经发生
  * 共享内存
    * 使得多个进程可以访问同一块内存空间
    * 需要依靠某种同步操作，如互斥锁和信号量
* 套接字socket
  * 可用于不同主机之间的进程通信
### 线程间的通信方式
* 临界区
* 互斥量
* 信号量
* 事件
  * 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作
### 多进程和多线程的使用场景
* 多进程：适用于CPU密集型，也适用于多机分布式场景中
* 多线程：适用于I/O密集型，也适用于单机多核分布式场景中

## 互斥锁与读写锁
* **互斥锁（mutex）**
  * **任何时刻，都只能有一个线程访问该对象**
  * 当获取锁操作失败时，**线程会进入睡眠**，等待锁释放时被唤醒
* **读写锁（rwlock）**
  * 读锁 + 写锁
  * 读操作：**同一时刻，多个线程可获得读操作**
  * 写操作：**同一时刻，只能有一个线程可以获得写操作**；其他获取写操作失败的线程都会进入睡眠状态，直到写锁释放时被唤醒
  * 注意：
    * **写锁会阻塞其他读写锁**，当有一个线程获得写锁在写时，读锁也不能被其他线程获取；
    * **写着优先于读者**，一旦有写着，则后续读者必须等待，唤醒时优先考虑写着
### 互斥锁与读写锁的区别
* 读写锁分为读者与写者， 互斥锁不分
* 互斥锁同一时间只允许一个线程访问该对象；读写锁同一时间只允许一个写着，但是允许多个读者同时访问
### Linux的4种锁机制
* **互斥锁（mutex）**
* **读写锁（rwlock）**
* **自旋锁（spinlock）**
  * 任何时刻，都只能有一个线程访问该对象
  * 当获取锁操作失败时，**线程不会进入睡眠**，而是在原地自旋，直到锁释放
  * 适用于加锁时间短暂的环境下
* **RCU（read-copy-update）**
  * 在修改数据时，首先需要读取数据
  * 然后生成一个 copy 副本，对副本进行修改
  * 修改完成后，再将老数据 update 成新的数据
  * 适用于在大量读操作，少量写操作的情况
