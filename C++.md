<span id="re_"></span>
# C++
[参考链接：C++面试知识点详细](https://github.com/huihut/interview)

[参考链接：C++面试常见问题](https://blog.csdn.net/u012864854/article/details/79777991)  

[参考链接：STL标准库常见面试题](https://blog.csdn.net/xiongluo0628/article/details/81546197)  

* [C++11新特性](#C++11新特性)
* [STL标准库](#STL标准库)
* [C++内存管理](#C++内存管理)
* [static关键字](#static关键字)
* [虚函数和纯虚函数](#虚函数和纯虚函数)
* [抽象类与接口](#抽象类与接口)
* [new和malloc](#new和malloc)
* [UDP与TCP](#UDP与TCP)
* [异步与实现方式](#异步与实现方式)
* [重载与重写](#重载与重写)
* [struct和class](#struct和class)
* [sizeof](#sizeof)

<span id="C++11新特性"></span>
## [C++11新特性](#re_)
* `lambda`表达式
* `auto`关键字 
  * 分析表达式所属的类型
* 字面值`nullptr`
  * 初始化空指针（空指针：不指向任何对象的指针）
  * 可以任意转换为其他任意类型指针
* 智能指针
  * 作用：自动释放所指向的对象 
  * 解决的问题：在内存管理中，1、忘记释放内存 2、尚有指针引用的情况下释放了内存
  * `Shared_ptr`可以让多个智能指针指向同一个对象
  * `unique_ptr`只容许一个指针独自指向一个对象。
* 范围`for`语句
  * `for(auto c : vec)`

<span id="STL标准库"></span>
## [STL标准库](#re_)
**容器、迭代器、算法**  
* vector
  * 底层结构：数组
  * 适用随机存储元素
  * 自增长机制：当分配的空间不够装下数据时，分配双倍于当前容量的存储区，把当前的值拷贝到新分配的内存中，并释放原来的内存。
  * 在插入位置和删除位置之后的所有迭代器和指针引用都会失效，同理，扩容之后的所有迭代器指针和引用也都会失效。
* list
  * 底层结构：双向链表
  * 适用插入与删除频繁
* priority_queue
  * 有权值的单向队列，根据堆来调整
* set  
  * 底层：红黑树  有序存储，  不重复
* multiset  
  * 底层：红黑树  有序存储，  可重复
* map  
  * 底层结构：红黑树  有序，  不重复
* multimap  
  * 底层结构：红黑树  有序，  可重复

<span id="C++内存管理"></span>
## [C++内存管理](#re_)
* **栈**：*存放函数参数与局部变量*  
* **堆**：*malloc是从堆上动态分配内存；需free释放*  
* **自由存储区**：*new是从自由存储区为对象动态分配内存；需delete手动释放*  
* **全局/静态存储区**：*保存自动全局变量和static变量*  
* **常量存储区**：*此存储区不可修改，常量（const）存在此处*  

### 堆栈的区别：栈的效率高，堆灵活  
* **管理方式不同**：堆需手动释放  
  * 栈是编译器自动管理的,堆需手动释放  
* **空间大小不同**：堆大  
  * 在32位OS下,堆内存可达到4GB的的空间,而栈就小得可怜.(VC6中,栈默认大小是1M,当然,你可以修改它)  
* **能否产生碎片不同**：堆会产生碎片  
  * 对于栈来说,进栈/出栈都有着严格的顺序(先进后出),不会产生碎片;而堆频繁的new/delete,会造成内存空间的不连续,容易产生碎片.  
* **生长方向不同**  
  * **栈向下生长**,以降序分配内存地址;**堆向上生长**,以升序分配内在地址.  
* **分配方式不同**  
  * **堆动态分配**,无静态分配;栈分为静态分配和动态分配,比如局部变量的分配,就是动态分配(alloca函数),函数参数的分配就是动态分配(我想的…).  
* **分配效率不同**：栈的效率高  
  * 栈是系统提供的数据结构,计算机会在底层对栈提供支持,进栈/出栈都有专门的指令,这就决定了栈的效率比较高.堆则不然,它由C/C++函数库提供,机制复杂,堆的效率要比栈低得多.  

## [static关键字](#re_)
* 同时编译多个文件时，
  * 所有未加static前缀的全局变量和函数对其他文件可见
  * 加了static关键字的变量和函数可对其它源文件隐藏
* 加了static前缀的变量默认初始值为0
* 静态数据成员
  * 不依赖于对象，依赖于类
  * **在对象诞生之前，静态数据成员在内存中就已经存在**
  * 普通的数据成员需要实例化后才存在
* 静态成员函数
  * 无法调用普通数据成员和普通成员函数，可以调用静态数据成员和静态成员函数

## [虚函数和纯虚函数](#re_)
* 抽象类：含有纯虚函数的类
* 非抽象类：只含有虚函数的类
* 虚函数可以直接使用，也可以被子类重载后以多态形式调用
* 纯虚函数必须在子类中实现该函数才可使用，因为**纯虚函数在基类中只有声明没有定义**
* 虚函数必须实现，对虚函数来说父类和子类都有各自的版本
### 虚函数原理
**虚函数是依赖于虚函数指针实现，每个拥有虚函数的类都有一个虚表，类的对象存在一个虚函数指针，指向实际类型的虚表。虚函数运行的时候，会根据虚函数指针找到正确的虚表，从而执行正确的虚函数。**

## [抽象类与接口](#re_)
* 抽象类
  * **含有纯虚函数的类**
  * 无法实例化对象，子类也有可能是抽象类
  * 抽象类可以实现接口
* 接口
  * 接口类更多的表达是一种能力或者协议
  * **接口中只能有抽象方法，即没有具体实现的方法**
  * 接口可以继承多个接口，不能继承或实现抽象类

## [new和malloc](#re_)
* malloc/free是标准库函数，new/delete是C++运算符
* **malloc失败返回空，new失败抛异常**
* new/delete会调用构造、析构函数，malloc/free不会，所以他们无法满足动态对象的要求。
* new返回有类型的指针，malloc返回无类型的指针
### new/delete的底层实现
* new
  * 调用底层全局函数operator new来申请空间
  * 在申请的空间上执行构造函数，完成对象的构造
* delete
  * 在空间上执行析构函数，清理对象中资源
  * 调用全局函数operator delete来释放对象的空间

<span id="UDP与TCP"></span>
## [UDP与TCP](#re_)
* TCP
  * 面向**连接**的**可靠传输**；注重数据安全
  * 只支持点到点
  * 面向字节流，将数据看成是字节流
* UDP
  * 面向**非连接**的**不可靠传输**；
  * 支持一对一，一对多，多对一和多对多的交互通信（广播通信）
  * 面向报文，没有拥塞控制（实时视频会议）

## [异步与实现方式](#re_)
* **异步**
  * **当一个异步过程调用发出后，调用者不能立刻得到结果**。实际上处理这个调用的部件在完成后，通过**状态 、通知和回调**来通知调用者
* 实现方式
  * 可以使用哪种方式依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。
  * 若执行部件用状态的方式，效率低（调用者需要每隔一段时间检查状态一次）
  * 通知的方式，效率高（几乎不需要做额外的操作）
  * 回调函数，与通知类似

## [重载与重写](#re_)
* 重写：**有继承关系**，对虚函数的重写
* 重载：**没有继承关系**，同名函数参数表不同
* 多态：**包括重载与重写**，同名函数同参数表，类型不同
* 重定义与隐藏：子类对父类的非虚函数再写一遍

<span id="struct和class"></span>
## struct和class
* **默认的继承访问权** 取决于子类，struct：public；class：private；
  ```cpp
  struct A
  {
   int a;
  };

  struct B: A   //共有继承
  {
   int b;
  };
  class C: A    //私有继承
  {
   int c
  };
  ```
* **默认的访问权限**
  ```cpp
  struct A
  {
   int a;
  };
  
  class B
  {
   int b;
  };
  
  int main()
  {
   A n;
   n.a = 10;  //可在结构外访问成员变量，所以struct默认是共有的
   B n1;
   n1.b = 10;  //在类外无法访问私有变量
   return 0;
  }
  ```

<span id="sizeof"></span>
## [sizeof](#re_)  [用法介绍](https://www.cnblogs.com/huolong-blog/p/7587711.html)
* 字节数
  * char 1
  * int 4
  * float 4
  * double 8
* 结构的sizeof
  ```cpp
  struct S2  
  {  
    int b;  
    char a;  
  };  
  sizeof(S2);  // 值为8，字节对齐，在char之后会填充3个字节。  

  struct S3  
  {  
  };  
  sizeof(S3);  // 值为1，空结构体也占内存
  ```
* 联合体的sizeof
  ```cpp
  union u  
  {  
      int a;  
      float b;  
      double c;  
      char d;  
  };  

  sizeof(u);  // 值为8;每个成员sizeof的最大值  
  ```
* 数组的sizeof
  ```cpp
  char a[10];  
  char n[] = "abc";   
  cout<<"char a[10]"<<sizeof(a)<<endl;//数组，值为10  
  cout<<"char n[] = /"abc/""<<sizeof(n)<<endl;//字符串数组，将'/0'计算进去，值为4
  
  // 作为形参
  void func(char a[3])  
  {  
    int c = sizeof(a); //c = 4，因为这里a不在是数组类型，而是指针，相当于char *a。  
  }  
  ```
