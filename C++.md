<span id="re_"></span>
# C++
[参考链接：C++面试知识点详细](https://github.com/huihut/interview)

[参考链接：C++面试常见问题](https://blog.csdn.net/u012864854/article/details/79777991)  

[参考链接：STL标准库常见面试题](https://blog.csdn.net/xiongluo0628/article/details/81546197)  

* [C++11新特性](#C++11新特性)
* [STL标准库](#STL标准库)
* [C++内存管理](#C++内存管理)
* [static关键字](#static关键字)
* [虚函数和纯虚函数](#虚函数和纯虚函数)
* [抽象类与接口](#抽象类与接口)
* [new和malloc](#new和malloc)
* [UDP与TCP](#UDP与TCP)
* [异步与实现方式](#异步与实现方式)
* [重载与重写](#重载与重写)
* [sizeof](#sizeof)

<span id="C++11新特性"></span>
## C++11新特性
* lambda表达式
* auto关键字
* 智能指针

<span id="STL标准库"></span>
## [STL标准库](#re_)
* vector
  * 适用随机存储元素
  * 自增长机制：当分配的空间不够装下数据时，分配双倍于当前容量的存储区，把当前的值拷贝到新分配的内存中，并释放原来的内存。
* list
  * 适用插入与删除频繁
* set  底层：红黑树  有序，  不重复
* multiset  底层：红黑树  有序，  可重复
* map  底层：红黑树  有序，  不重复
* multimap  底层：红黑树  有序，  可重复

<span id="C++内存管理"></span>
## C++内存管理
* **栈**：*存放函数参数与局部变量*  
* **堆**：*malloc是从堆上动态分配内存；需free释放*  
* **自由存储区**：*new是从自由存储区为对象动态分配内存；需delete手动释放*  
* **全局/静态存储区**：*保存自动全局变量和static变量*  
* **常量存储区**：*此存储区不可修改，常量（const）存在此处*  

### 堆栈的区别：栈的效率高，堆灵活  
* **管理方式不同**：堆需手动释放  
  * 栈是编译器自动管理的,堆需手动释放  
* **空间大小不同**：堆大  
  * 在32位OS下,堆内存可达到4GB的的空间,而栈就小得可怜.(VC6中,栈默认大小是1M,当然,你可以修改它)  
* **能否产生碎片不同**：堆会产生碎片  
  * 对于栈来说,进栈/出栈都有着严格的顺序(先进后出),不会产生碎片;而堆频繁的new/delete,会造成内存空间的不连续,容易产生碎片.  
* **生长方向不同**  
  * **栈向下生长**,以降序分配内存地址;**堆向上生长**,以升序分配内在地址.  
* **分配方式不同**  
  * **堆动态分配**,无静态分配;栈分为静态分配和动态分配,比如局部变量的分配,就是动态分配(alloca函数),函数参数的分配就是动态分配(我想的…).  
* **分配效率不同**：栈的效率高  
  * 栈是系统提供的数据结构,计算机会在底层对栈提供支持,进栈/出栈都有专门的指令,这就决定了栈的效率比较高.堆则不然,它由C/C++函数库提供,机制复杂,堆的效率要比栈低得多.  

## static关键字
* 同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性
* 加了static关键字的变量和函数可对其它源文件隐藏
* 加了static前缀的变量默认初始值为0

## 虚函数和纯虚函数
* 抽象类：含有纯虚函数的类
* 非抽象类：只含有虚函数的类
* 虚函数可以直接使用，也可以被子类重载后以多态形式调用
* 纯虚函数必须在子类中实现该函数才可使用，因为**纯虚函数在基类中只有声明没有定义**
* 虚函数必须实现，对虚函数来说父类和子类都有各自的版本

## 抽象类与接口
* 抽象类
  * **含有纯虚函数的类**
  * 无法实例化对象，子类也有可能是抽象类
  * 抽象类可以实现接口
* 接口
  * 接口类更多的表达是一种能力或者协议
  * **接口中只能有抽象方法，即没有具体实现的方法**
  * 接口可以继承多个接口，不能继承或实现抽象类

## new和malloc
* malloc/free是标准库函数，new/delete是C++运算符
* malloc失败返回空，new失败抛异常
* new/delete会调用构造、析构函数，malloc/free不会，所以他们无法满足动态对象的要求。
* new返回有类型的指针，malloc返回无类型的指针

<span id="UDP与TCP"></span>
## UDP与TCP
* TCP
  * 面向**连接**的**可靠传输**；
  * 只支持点到点
  * 面向字节流，将数据看成是字节流
* UDP
  * 面向**非连接**的**不可靠传输**；
  * 支持一对一，一对多，多对一和多对多的交互通信（广播通信）
  * 面向报文，没有拥塞控制（实时视频会议）


## [异步与实现方式](#re_)
* **异步**
  * **当一个异步过程调用发出后，调用者不能立刻得到结果**。实际上处理这个调用的部件在完成后，通过**状态 、通知和回调**来通知调用者
* 实现方式
  * 可以使用哪种方式依赖于执行部件的实现，除非执行部件提供多种选择，否则不受调用者控制。
  * 若执行部件用状态的方式，效率低（调用者需要每隔一段时间检查状态一次）
  * 通知的方式，效率高（几乎不需要做额外的操作）
  * 回调函数，与通知类似

## [重载与重写](#re_)
* 重写：对虚函数的重写
* 重载：同名函数参数表不同
* 多态：同名函数同参数表，类型不同
* 重定义与隐藏：子类对父类的非虚函数再写一遍

<span id="sizeof"></span>
## [sizeof](#re_)  [用法介绍](https://www.cnblogs.com/huolong-blog/p/7587711.html)
* 字节数
  * char 1
  * int 4
  * float 4
  * double 8
* 结构的sizeof
  ```cpp
  struct S2  
  {  
    int b;  
    char a;  
  };  
  sizeof(S2);  // 值为8，字节对齐，在char之后会填充3个字节。  

  struct S3  
  {  
  };  
  sizeof(S3);  // 值为1，空结构体也占内存
  ```
* 联合体的sizeof
  ```cpp
  union u  
  {  
      int a;  
      float b;  
      double c;  
      char d;  
  };  

  sizeof(u);  // 值为8;每个成员sizeof的最大值  
  ```
* 数组的sizeof
  ```cpp
  char a[10];  
  char n[] = "abc";   
  cout<<"char a[10]"<<sizeof(a)<<endl;//数组，值为10  
  cout<<"char n[] = /"abc/""<<sizeof(n)<<endl;//字符串数组，将'/0'计算进去，值为4
  
  // 作为形参
  void func(char a[3])  
  {  
    int c = sizeof(a); //c = 4，因为这里a不在是数组类型，而是指针，相当于char *a。  
  }  
  ```
