# 计算机网络
* [TCP](#TCP)
* [HTTP和HTTPS](#HTTP和HTTPS)

## TCP
### TCP保证可靠性
* **序列号、确认应答、超时重传**
  * 数据到达接收方，接收方发出确认应答，确认序列号会说明下一个需要接受的数据序列号
  * 发送方迟迟没有收到应答，会等待一定时间后进行重传
* **窗口控制**与高速重发控制/快速重传
  * TCP利用窗口控制来提高传输效率，在一个窗口大小内不一定要等要应答才能发送下一段数据
  * 窗口大小就是无需等待确认而可以继续发送数据的最大值
  * 解释：
    * 使用窗口控制，如果数据段1001-2000丢失，后面数据每次传输，确认应答都会不停地发送序号为1001的应答，表示我要接收1001开始的数据，发送端如果收到3次相同应答，就会立刻进行重发；但还有种情况有可能是数据都收到了，但是有的应答丢失了，这种情况不会进行重发，因为发送端知道，如果是数据段丢失，接收端不会放过它的，会疯狂向它提醒......
* **拥塞控制**
  * 解决的问题：当把窗口定的很大，发送端连续发送大量的数据，可能会造成网络的拥堵
  * 慢启动
    * 定义拥塞窗口，一开始大小为1，之后每次收到确认应答，将拥塞窗口 *2；
  * 拥塞避免
    * 设置慢启动阈值，当达到阈值后，拥塞窗口变成加法增加（每次确认应答，拥塞窗口 +1）
  * 报文段超时重传
    * 一旦发生，需要先将阈值设为窗口大小的一半，并且将窗口大小设为初值1，然后进入慢启动
  * 快速重传
    * 接收方每次收到一个失序的报文段后就立即发出重复确认，发送方只要连续收到三个重复确认就立即重传
### TCP三次握手四次挥手
* 三次握手
  * C->SYN->S
    * 客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认
  * S->ACK+SYN->C
    * 服务器收到syn包，必须确认客户的syn(ack = x + 1), 同时自己也发送一个syn包（syn=y）,即SYN+ACK包，此时服务器进入SYN_RECV状态
  * C->ACK->S
    * 客户端收到服务器的 SYN + ACK 包，向服务器发送确认包ACK(ACK = y + 1),此包发送完毕，客户端和服务器进入 ESTABLISHED 状态
* 四次挥手
  * C->FIN->S
    * 主动关闭方，发送FIN，告诉被动方自己不会再发数据了
  * S->ACK->C
    * 被动方收到 FIN 包，发送 ACK (收到序列号 + 1)确认
  * S->FIN->C
    * 被动方发送一个 FIN 包，告诉主动方我也不会再给你发送数据了
  * C->ACK->S
    * 主动方收到 FIN 后，发送一个 ACK (收到序列号 + 1)给被动方，至此完成四次挥手

## HTTP和HTTPS
* **HTTPS 优点**
  * **安全**，传输过程中使用密钥进行加密
  * **准确**，协议可以认证用户和服务器，确保数据发送到正确的用户和服务器
* **HTTPS 缺点**
  * **延时较高**，在进行HTTP会话之前还需要进行 SSL 握手
  * **部署成本较高**，协议需要使用证书来验证自身的安全性，需要购买CA证书；另一方面由于协议需要进行加解密计算，需要服务器配置数目高
### HTTP和HTTPS的不同
* HTTPS更安全；HTTP协议是以明文的方式在网络中传输数据，HTTPS传输的数据是经过 SSL 加密后的
* HTTP的端口80； HTTPS协议端口443；
### HTTP返回码
* 1xx：临时响应
* 2xx:成功
* 3xx:重定向
  * 301：永久重定向
  * 302：临时重定向
* 4xx:请求错误
  * 403：服务器拒绝请求
  * 404：服务器找不到请求的网页
* 5xx:服务器端错误
