# Interview
* [C++](https://github.com/FangChao1086/Interview//blob/master/C%2B%2B.md)
* [python](https://github.com/FangChao1086/Interview/tree/master/python)
* [Linux](https://github.com/FangChao1086/Interview/blob/master/Linux.md)
  * [命令搜索](https://wangchujiang.com/linux-command/)  
* [mysql常用命令](https://mp.weixin.qq.com/s/wUCVeYLxx5JL2Xy-XJNvNQ)  
* [数据结构](https://github.com/FangChao1086/Interview/blob/master/数据结构.md)  
[操作系统](#操作系统)  
* [计算机网络](https://github.com/FangChao1086/Interview/blob/master/计算机网络.md)  
* [设计模式](https://github.com/FangChao1086/Interview/blob/master/设计模式.md)

<span id="操作系统"></span>
# 操作系统
[进程与线程](#进程与线程)  
[互斥锁与读写锁](#互斥锁与读写锁)  
[内存溢出和内存泄漏](#内存溢出和内存泄漏)

## 进程与线程
* **进程**
  * 对运行时程序的封装
  * **系统进行资源调度和分配的的基本单位**
  * 实现了操作系统的并发
* **线程**
  * 进程的子任务
  * **CPU调度和分派的基本单位**
  * 用于保证程序的实时性，实现进程内部的并发
### 区别
* 线程依赖于进程而存在
  * 一个线程只能属于一个进程，一个进程至少有一个线程，可以有多线程
* 进程是资源分配的最小单位，线程是CPU调度的最小单位
* 一个进程崩溃，不会对其他进程产生影响；而一个线程崩溃，会让同一进程内的其他线程也死掉。
* 系统开销  进程大
  * 创建或撤消进程时，操作系统所付出的开销将显著地大于在创建或撤消线程时的开销
* 通信
  * 同一进程中的多个线程具有相同的地址空间，致使它们之间的同步和通信的实现，也变得比较容易
  * 进程间通信，需要进程同步和互斥手段的辅助
* 调试
  * 进程简单可靠性高，线程编程调试相对复杂
### 进程间的通信方式
**管道**、系统IPC（包括**消息队列、信号量、信号、共享内存**等）、以及套接字socket
* 管道
  * 无名管道：可用于具有亲缘关系的父子进程间的通信
  * 有名管道：允许无亲缘关系进程间的通信
* 系统IPC
  * 消息队列
    * 消息不一定要以先进先出的次序读取,也可以按消息的类型读取
  * 信号量
    * 是一个计数器，可以用来控制多个进程对共享资源的访问
    * 用于实现进程间的互斥与同步，而不是用于存储进程间通信数据
  * 信号
    * 用于通知接收进程某个事件已经发生
  * 共享内存
    * 使得多个进程可以访问同一块内存空间
    * 需要依靠某种同步操作，如互斥锁和信号量
* 套接字socket
  * 可用于不同主机之间的进程通信
### 线程间的通信方式
* 临界区
  * 通过多线程的串行化来访问公共资源或一段代码
* 互斥量
  * 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限
  * 互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问
* 信号量
  * 允许多个线程在同一时刻去访问同一个资源
  * 一般需要限制同一时刻访问此资源的最大线程数目
* 事件
  * 通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作
### 多进程和多线程的使用场景
* 多进程：适用于CPU密集型，也适用于多机分布式场景中
* 多线程：适用于I/O密集型，也适用于单机多核分布式场景中

**<details><summary>进程状态转换图</summary>**
 
<div align=center><img src="https://github.com/FangChao1086/Interview/blob/master/依赖文件/操作系统_进程状态转换图.png"></div>

* 创建状态
  * 进程正在被创建
* 就绪状态
  * 进程被加入到就绪队列中等待CPU调度
* 执行状态
  * 进程正在运行
* 等待阻塞状态
  * 进程由于某种原因，比如等待 I/O ，等待设备， 而暂时不能运行
* 终止状态
  * 进程运行完毕 
</details>

## 互斥锁与读写锁
* **互斥锁（mutex）**
  * **任何时刻，都只能有一个线程访问该对象**
  * 当获取锁操作失败时，**线程会进入睡眠**，等待锁释放时被唤醒
* **读写锁（rwlock）**
  * 读锁 + 写锁
  * 读操作：**同一时刻，多个线程可获得读操作**
  * 写操作：**同一时刻，只能有一个线程可以获得写操作**；其他获取写操作失败的线程都会进入睡眠状态，直到写锁释放时被唤醒
  * 注意：
    * **写锁会阻塞其他读写锁**，当有一个线程获得写锁在写时，读锁也不能被其他线程获取；
    * **写着优先于读者**，一旦有写着，则后续读者必须等待，唤醒时优先考虑写着
### 互斥锁与读写锁的区别
* 读写锁分为读者与写者， 互斥锁不分
* 互斥锁同一时间只允许一个线程访问该对象；读写锁同一时间只允许一个写着，但是允许多个读者同时访问
### Linux的4种锁机制
* **互斥锁（mutex）**
* **读写锁（rwlock）**
* **自旋锁（spinlock）**
  * 任何时刻，都只能有一个线程访问该对象
  * 当获取锁操作失败时，**线程不会进入睡眠**，而是在原地自旋，直到锁释放
  * 适用于加锁时间短暂的环境下
* **RCU（read-copy-update）**
  * 在修改数据时，首先需要读取数据
  * 然后生成一个 copy 副本，对副本进行修改
  * 修改完成后，再将老数据 update 成新的数据
  * 适用于在大量读操作，少量写操作的情况
### 死锁产生的必要条件
1.互斥条件：一个资源每次只能被一个进程使用。
2.请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3.不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。
4.循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

## 内存溢出和内存泄漏
* **内存溢出**  程序申请内存时，没有足够的内存供申请者使用
  * 原因
    * 内存中加载的数据量过大
    * 代码中存在死循环
* **内存泄漏**  程序未能释放掉不再使用的内存，造成了内存的浪费
  * 原因
    * 堆内存泄漏
      * new/malloc 分配的内存没有使用 delete/free 释放
    * 系统资源泄漏
      * 程序使用系统分配的资源比如 Bitmap,handle ,SOCKET等没有使用相应的函数释放掉
    * 没有将基类的析构函数定义为虚函数
      * 当基类指针指向子类对象时，如果基类的析构函数不是virtual, 那么子类的析构函数不会被调用，子类资源不会被释放
